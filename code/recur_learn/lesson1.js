/*
*  递归的学习
*  题号 93
*  1，复原ip地址  给定一个 只包含数字 的字符串，复原它并返回 所有 可能的 IP 地址格式
*  思路： 1，使用3个点 将字符串分成四部分，每个部分不超过3个字符，并且每个部分的值都是在0到255之间
*         2，先找第一部分，如果说第一部分是1位数，那么剩下的部分就是剩下的是哪个部分的所有数
*         3，假如找到第一部分了 ，第二部分也按照第一部分的那样 找第二部分 ，将不合理的部分去掉 也就是值不满足0到255之间
*         4，当剩下的值不能让最后一部分成立一个合理的值 那么这条线就放弃了 依次递归进行
*         5, 递归的本质就是重复操作 每次的输入和输出是一样的 不知道执行的次数    注意点：还有就是注意边界问题 以及要有返回
*
* */
export default (str) => {
    // 保存所有符合条件的IP地址
    let r = [];
    // 分四步递归处理ip分段
    /*
    *  search递归函数
    *  cur取出来的字符串
    *  sub 剩余子串
    * */
    let search = (cur, sub) => {
        // 非法输入过滤，LeetCode测试用例()
        if (sub.length > 12) {
            return
        }
        // 边界条件 这一点听的不是很明白 什么时候跳出函数是遇到边界的时候
        if (cur.length === 4 && cur.join('') === str) {
            r.push(cur.join('.'))
        } else {
            // 正常的处理过程  Math.min(3, sub.length)；取最小值操作 最多取3位字符串，如果最多没有3位 就其剩余字符串的所有
            for (let i = 0, len = Math.min(3, sub.length), tmp; i < len; i++) {
                tmp = sub.substr(0, i + 1);
                if (tmp - 256 < 0) { // 不是很理解
                    // 转换下数据类型，如 01为1（LeetCode测试用例）
                    search(cur.concat([tmp * 1]), sub.substr(i + 1))
                }
            }
        }
    }
    search([], str);
    return r
}
